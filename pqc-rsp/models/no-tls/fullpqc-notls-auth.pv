(* =====================================================================
   SGP.22 Consumer eSIM Provisioning - PHASE A ONLY: KEM-based Mutual Authentication
   with PUBLIC ES9+ Channel (No LPA - Direct SM-DP+ â†” eUICC)
   
   FULL PQC STACK:
   - Certificate chain: PQ signatures (Dilithium)
   - Certificates directly contain KEM public keys
   - Handshake auth: ML-KEM (KEMTLS)
   
   PUBLIC CHANNEL SECURITY:
   - ALL communication is over PUBLIC ES9+ channel
   - No LPA relay - direct SM-DP+ to eUICC communication
   - Transcript binding + Finished messages provide authentication
   - Transport-independent security - secure even without TLS
   ===================================================================== *)

(* ProVerif settings for termination *)
set selFun = Term.
set reconstructTrace = false.

(* ===== CHANNELS ===== *)
free c         : channel.           (* Public channel: certificates *)
free ES9       : channel.           (* PUBLIC ES9+: attacker can see/modify *)


(* ===== DATA TYPES ===== *)
type Id_t.      (* Entity identifier *)
type Tid_t.     (* TransactionID *)
type Nonce_t.   (* Challenges for freshness *)
type Tag_t.     (* Role tags *)

(* KEM key types - deterministic model *)
type KEMsk_t.   (* KEM secret key *)
type KEMpk_t.   (* KEM public key *)
type KEMss_t.   (* KEM shared secret *)

(* Session key type *)
type SessionKey_t.

(* PQ Signature types for certificates (Dilithium) *)
type PQSigSK_t.  (* PQ signature secret key *)
type PQSigPK_t.  (* PQ signature public key *)
type PQSig_t.    (* PQ signature *)


(* ===== CONSTANTS ===== *)
const ID_SMDP   : Id_t.
const ID_EUICC  : Id_t.

const tag_dp    : Tag_t.
const tag_eu    : Tag_t.

(* Root CA PQ signature secret key *)
const SK_ROOT_CA : PQSigSK_t [private].

(* SM-DP+ static KEM private key *)
const SK_SMDP_KEM : KEMsk_t [private].


(* ===== CRYPTO: PQ SIGNATURES (Dilithium) ===== *)
fun pq_sig_pk(PQSigSK_t) : PQSigPK_t.
fun pq_sign(bitstring, PQSigSK_t) : PQSig_t.
reduc forall m:bitstring, sk:PQSigSK_t;
  pq_verify(pq_sign(m, sk), m, pq_sig_pk(sk)) = true.


(* ===== CRYPTO: ML-KEM (Correct IND-CCA secure model) ===== *)
type KEMcoin_t.   (* Encapsulation randomness - private to encapsulator *)

fun kem_pk(KEMsk_t) : KEMpk_t.

fun kem_enc(KEMpk_t, KEMcoin_t) : bitstring [data].
fun kem_ss(KEMpk_t, KEMcoin_t) : KEMss_t [private].

reduc forall sk:KEMsk_t, r:KEMcoin_t;
  kem_dec(kem_enc(kem_pk(sk), r), sk) = kem_ss(kem_pk(sk), r).


(* ===== KEY DERIVATION ===== *)
fun kdf_session(KEMss_t, KEMss_t, KEMss_t, bitstring) : SessionKey_t.


(* ===== MAC FUNCTIONS ===== *)
fun session_mac(SessionKey_t, bitstring) : bitstring.


(* ===== SYMMETRIC ENCRYPTION (for session key secrecy test) ===== *)
fun senc_test(bitstring, SessionKey_t) : bitstring.
reduc forall m:bitstring, k:SessionKey_t; sdec_test(senc_test(m, k), k) = m.


(* ===== EVENTS ===== *)

event SMDP_BEGIN(Id_t, Tid_t, Nonce_t, Nonce_t).
event SMDP_SENT_AUTH(Id_t, Tid_t, Nonce_t, Nonce_t, Id_t).
event EUICC_AUTH_OK(Id_t, Tid_t, Nonce_t, Nonce_t, Id_t).
event SMDP_AUTH_OK(Id_t, Tid_t, Nonce_t, Id_t).

event EUICC_SENT_FINISHED(Id_t, Tid_t, bitstring).
event SMDP_VERIFIED_FINISHED(Id_t, Tid_t, bitstring).
event SMDP_SENT_FINISHED(Id_t, Tid_t, bitstring).
event EUICC_VERIFIED_FINISHED(Id_t, Tid_t, bitstring).

event EUICC_KEY(Id_t, Tid_t, SessionKey_t).
event SMDP_KEY(Id_t, Tid_t, SessionKey_t).


(* ===== QUERIES ===== *)

(* --- CRITICAL PROPERTIES --- *)

(* #9: Mutual Authentication - eUICC authenticates SM-DP+ *)
query dev:Id_t, tid:Tid_t, e:Nonce_t, s:Nonce_t;
  inj-event(EUICC_AUTH_OK(dev, tid, e, s, ID_SMDP))
    ==> inj-event(SMDP_SENT_AUTH(dev, tid, e, s, ID_SMDP)).

(* #9: Mutual Authentication - SM-DP+ authenticates eUICC *)
query dev:Id_t, tid:Tid_t, s:Nonce_t, transcript:bitstring;
  inj-event(SMDP_AUTH_OK(dev, tid, s, ID_EUICC))
    ==> inj-event(EUICC_SENT_FINISHED(dev, tid, transcript)).

(* #3: Session Key Agreement - both parties derive same key *)
query dev:Id_t, tid:Tid_t, k:SessionKey_t;
  inj-event(SMDP_KEY(dev, tid, k)) ==> inj-event(EUICC_KEY(dev, tid, k)).

(* #12: Session Key Secrecy - attacker cannot recover data protected by session key *)
free secret_payload : bitstring [private].
query attacker(secret_payload).

(* #14: Forward Secrecy - session key remains secure after long-term key compromise *)
query attacker(secret_payload) phase 1.

(* --- IMPORTANT PROPERTIES --- *)

(* #10: Injective Agreement - Finished message authenticity *)
query dev:Id_t, tid:Tid_t, transcript:bitstring;
  inj-event(SMDP_VERIFIED_FINISHED(dev, tid, transcript)) ==>
    inj-event(EUICC_SENT_FINISHED(dev, tid, transcript)).

query dev:Id_t, tid:Tid_t, transcript:bitstring;
  inj-event(EUICC_VERIFIED_FINISHED(dev, tid, transcript)) ==>
    inj-event(SMDP_SENT_FINISHED(dev, tid, transcript)).

(* #27: TRANSPORT INDEPENDENCE - Security holds over PUBLIC ES9+ channel *)
(* This is proven by the model itself: ES9 is a public channel! *)


(* =====================================================================
   eUICC PROCESS - Phase A Only (Public ES9+, No LPA)
   ===================================================================== *)
let EUICC(PK_ROOT:PQSigPK_t, dev:Id_t) =
  (* Setup: Long-term KEM identity *)
  new SK_EUICC_KEM : KEMsk_t;
  let PK_EUICC_KEM = kem_pk(SK_EUICC_KEM) in

  (* Issue certificate: sign (id, pk, role) *)
  let cert_tbs_eu:bitstring = (ID_EUICC, PK_EUICC_KEM, tag_eu) in
  let sig_eu = pq_sign(cert_tbs_eu, SK_ROOT_CA) in
  out(c, (ID_EUICC, PK_EUICC_KEM, tag_eu, sig_eu));

  (* Generate ephemeral KEM keypair for this session *)
  new SK_EUICC_EPH : KEMsk_t;
  let PK_EUICC_EPH = kem_pk(SK_EUICC_EPH) in

  new eChal : Nonce_t;

  (* Step 1: Send to SM-DP+ via public ES9+ channel *)
  out(ES9, (dev, eChal, PK_EUICC_EPH, PK_EUICC_KEM, sig_eu));

  (* Step 2: Receive from SM-DP+ via public ES9+ channel *)
  in(ES9,
     (tid         : Tid_t,
      serverNonce : Nonce_t,
      CT_EPH      : bitstring,
      CT_CLIENT   : bitstring,
      PK_SMDP_KEM : KEMpk_t,
      sig_dp      : PQSig_t));

  (* Verify SM-DP+ certificate *)
  let cert_tbs_dp:bitstring = (ID_SMDP, PK_SMDP_KEM, tag_dp) in
  if pq_verify(sig_dp, cert_tbs_dp, PK_ROOT) = true then

  (* KEM decapsulation *)
  let SS_EPH = kem_dec(CT_EPH, SK_EUICC_EPH) in
  let SS_CLIENT = kem_dec(CT_CLIENT, SK_EUICC_KEM) in

  (* Encapsulate to SM-DP+ *)
  new r_server : KEMcoin_t;
  let CT_SERVER = kem_enc(PK_SMDP_KEM, r_server) in
  let SS_SERVER = kem_ss(PK_SMDP_KEM, r_server) in

  (* Derive session key with transcript binding *)
  let transcript:bitstring = (eChal, serverNonce, tid, CT_EPH, CT_CLIENT, CT_SERVER,
                              PK_EUICC_KEM, PK_SMDP_KEM) in
  let session_key = kdf_session(SS_EPH, SS_SERVER, SS_CLIENT, transcript) in

  let Finished_EU = session_mac(session_key, transcript) in

  event EUICC_SENT_FINISHED(dev, tid, transcript);
  event EUICC_KEY(dev, tid, session_key);

  (* Session key secrecy test: encrypt secret payload under session key *)
  out(ES9, senc_test(secret_payload, session_key));

  (* Step 3: Send CT_SERVER + Finished via public ES9+ *)
  out(ES9, (tid, CT_SERVER, Finished_EU));

  (* Step 4: Receive and verify SM-DP+ Finished via public ES9+ *)
  in(ES9, (tid2:Tid_t, Finished_DP_in:bitstring));
  if tid2 = tid then

  let expected_finished_dp = session_mac(session_key, (transcript, Finished_EU)) in
  if Finished_DP_in = expected_finished_dp then

  event EUICC_VERIFIED_FINISHED(dev, tid, transcript);
  event EUICC_AUTH_OK(dev, tid, eChal, serverNonce, ID_SMDP).



(* =====================================================================
   SM-DP+ PROCESS - Phase A Only (Public ES9+)
   ===================================================================== *)
let SMDP(PK_ROOT:PQSigPK_t, dev:Id_t) =
  let PK_SMDP_KEM = kem_pk(SK_SMDP_KEM) in

  (* Issue certificate *)
  let cert_tbs_dp:bitstring = (ID_SMDP, PK_SMDP_KEM, tag_dp) in
  let sig_dp = pq_sign(cert_tbs_dp, SK_ROOT_CA) in
  out(c, (ID_SMDP, PK_SMDP_KEM, tag_dp, sig_dp));

  in(ES9,
     (devS        : Id_t,
      eChalS      : Nonce_t,
      PK_EUICC_EPH: KEMpk_t,
      PK_EUICC_KEM: KEMpk_t,
      sig_eu      : PQSig_t));
  if devS = dev then

  (* Verify eUICC certificate *)
  let cert_tbs_eu:bitstring = (ID_EUICC, PK_EUICC_KEM, tag_eu) in
  if pq_verify(sig_eu, cert_tbs_eu, PK_ROOT) = true then

  new tid : Tid_t;
  new serverNonce : Nonce_t;
  event SMDP_BEGIN(devS, tid, eChalS, serverNonce);

  (* KEM encapsulations *)
  new r_eph : KEMcoin_t;
  let CT_EPH = kem_enc(PK_EUICC_EPH, r_eph) in
  let SS_EPH = kem_ss(PK_EUICC_EPH, r_eph) in

  new r_client : KEMcoin_t;
  let CT_CLIENT = kem_enc(PK_EUICC_KEM, r_client) in
  let SS_CLIENT = kem_ss(PK_EUICC_KEM, r_client) in

  event SMDP_SENT_AUTH(devS, tid, eChalS, serverNonce, ID_SMDP);

  out(ES9, (tid, serverNonce, CT_EPH, CT_CLIENT, PK_SMDP_KEM, sig_dp));

  in(ES9, (tid2:Tid_t, CT_SERVER:bitstring, Finished_EU_in:bitstring));
  if tid2 = tid then

  let SS_SERVER = kem_dec(CT_SERVER, SK_SMDP_KEM) in

  let transcript:bitstring = (eChalS, serverNonce, tid, CT_EPH, CT_CLIENT, CT_SERVER,
                              PK_EUICC_KEM, PK_SMDP_KEM) in
  let session_key = kdf_session(SS_EPH, SS_SERVER, SS_CLIENT, transcript) in

  let expected_finished_eu = session_mac(session_key, transcript) in
  if Finished_EU_in = expected_finished_eu then

  event SMDP_VERIFIED_FINISHED(dev, tid, transcript);
  event SMDP_KEY(devS, tid, session_key);

  let Finished_DP = session_mac(session_key, (transcript, Finished_EU_in)) in
  event SMDP_SENT_FINISHED(dev, tid, transcript);

  out(ES9, (tid, Finished_DP));
  event SMDP_AUTH_OK(dev, tid, serverNonce, ID_EUICC).



(* =====================================================================
   MAIN PROCESS
   ===================================================================== *)
process
  let PK_ROOT = pq_sig_pk(SK_ROOT_CA) in
  out(c, PK_ROOT);

  new devMain : Id_t;
  
  (
    ( !SMDP(PK_ROOT, devMain)
    | !EUICC(PK_ROOT, devMain)
    )
    
    (* Forward Secrecy Test: leak long-term key after protocol *)
  | ( phase 1;
      out(c, SK_SMDP_KEM)
    )
  )
