(* =====================================================================
   SGP.22 Consumer eSIM Provisioning - PHASE B ONLY: Profile Download
   with PUBLIC ES9+ Channel (No LPA - Direct SM-DP+ â†” eUICC)
   
   FULL PQC STACK:
   - KEM-based authentication throughout
   
   PUBLIC CHANNEL SECURITY:
   - ALL communication is over PUBLIC ES9+ channel
   - No LPA relay - direct SM-DP+ to eUICC communication
   - KEM-based authentication provides message authenticity
   - Separate auth KEM layer binds profile to eUICC identity
   - Transport-independent security
   
   Phase B: Profile Download only
   Assumes Phase A authentication already completed
   ===================================================================== *)

(* ProVerif settings for termination *)
set selFun = Term.
set reconstructTrace = false.

(* ===== CHANNELS ===== *)
free c         : channel.           (* Public channel: certificates *)
free ES9       : channel.           (* PUBLIC ES9+: attacker can see/modify *)


(* ===== DATA TYPES ===== *)
type Id_t.      (* Entity identifier *)
type Tid_t.     (* TransactionID *)

(* KEM key types - deterministic model *)
type KEMsk_t.   (* KEM secret key *)
type KEMpk_t.   (* KEM public key *)
type KEMss_t.   (* KEM shared secret *)

(* Profile Download types *)
type SymKey_t.      (* Symmetric keys for profile encryption *)
type Profile_t.     (* eSIM Profile *)
type ICCID_t.       (* Profile identifier *)

(* Encapsulation randomness *)
type KEMcoin_t.


(* ===== CONSTANTS ===== *)
const ID_SMDP   : Id_t.
const ID_EUICC  : Id_t.

(* SM-DP+ static KEM private key *)
const SK_SMDP_KEM : KEMsk_t [private].


(* ===== CRYPTO: ML-KEM ===== *)
fun kem_pk(KEMsk_t) : KEMpk_t.

fun kem_enc(KEMpk_t, KEMcoin_t) : bitstring [data].
fun kem_ss(KEMpk_t, KEMcoin_t) : KEMss_t [private].

reduc forall sk:KEMsk_t, r:KEMcoin_t;
  kem_dec(kem_enc(kem_pk(sk), r), sk) = kem_ss(kem_pk(sk), r).


(* ===== KEY DERIVATION ===== *)
fun kdf_profile(KEMss_t) : SymKey_t.
fun kdf_bind(KEMss_t, Tid_t) : SymKey_t.
fun kdf_auth(KEMss_t, Tid_t) : SymKey_t.
fun kdf_install(KEMss_t, Tid_t, ICCID_t, KEMpk_t, bitstring) : SymKey_t.


(* ===== SYMMETRIC ENCRYPTION ===== *)
fun senc(Profile_t, SymKey_t) : bitstring.
reduc forall p:Profile_t, k:SymKey_t;
  sdec(senc(p, k), k) = p.


(* ===== MAC FUNCTIONS ===== *)
fun mac(SymKey_t, bitstring) : bitstring.

(* Message constructors for MAC inputs *)
fun msg_prepare(Tid_t) : bitstring [data].
fun msg_response(Tid_t, KEMpk_t) : bitstring [data].
fun msg_profile(Tid_t, bitstring, bitstring) : bitstring [data].
fun msg_install(Tid_t, ICCID_t, KEMpk_t) : bitstring [data].


(* ===== EVENTS ===== *)

event SMDP_BOUND_PROFILE(Id_t, Tid_t, Profile_t).
event EUICC_PROFILE_INSTALLED(Id_t, Tid_t, Profile_t, ICCID_t).
event SMDP_INSTALL_CONFIRMED(Id_t, Tid_t, ICCID_t).


(* ===== QUERIES ===== *)

(* --- CRITICAL PROPERTIES --- *)

(* #13: Profile Data Confidentiality - attacker cannot learn profile *)
free secret_profile : Profile_t [private].
query attacker(secret_profile).

(* #14: Forward Secrecy - profile remains secret after long-term key compromise *)
query attacker(secret_profile) phase 1.

(* --- IMPORTANT PROPERTIES --- *)

(* #10: Injective Agreement - Profile installation authenticity *)
query dev:Id_t, tid:Tid_t, profile:Profile_t, iccid:ICCID_t;
  inj-event(EUICC_PROFILE_INSTALLED(dev, tid, profile, iccid)) ==>
    inj-event(SMDP_BOUND_PROFILE(dev, tid, profile)).

(* #10: Injective Agreement - Installation confirmation authenticity *)
query dev:Id_t, tid:Tid_t, profile:Profile_t, iccid:ICCID_t;
  inj-event(SMDP_INSTALL_CONFIRMED(dev, tid, iccid)) ==>
    inj-event(EUICC_PROFILE_INSTALLED(dev, tid, profile, iccid)).

(* #17: Profile Integrity - implicit via MAC verification in protocol *)
(* #27: TRANSPORT INDEPENDENCE - Security holds over PUBLIC ES9+ channel *)
(* This is proven by the model itself: ES9 is a public channel! *)


(* =====================================================================
   eUICC PROCESS - Phase B Only (Public ES9+, No LPA)
   ===================================================================== *)
let EUICC(dev:Id_t, tid:Tid_t, PK_SMDP_KEM:KEMpk_t, SK_EUICC_KEM:KEMsk_t) =
  
  (* Step 1: Receive PrepareDownload from SM-DP+ via ES9 *)
  in(ES9,
     (tid_pd     : Tid_t,
      CT_PREPARE : bitstring,
      prepare_mac: bitstring));
  if tid_pd = tid then

  let SS_PREPARE = kem_dec(CT_PREPARE, SK_EUICC_KEM) in
  let k_prepare = kdf_bind(SS_PREPARE, tid) in

  let expected_prepare_mac = mac(k_prepare, msg_prepare(tid)) in
  if prepare_mac = expected_prepare_mac then

  (* Generate ephemeral key for profile encryption *)
  new SK_EU_PROFILE : KEMsk_t;
  let PK_EU_PROFILE = kem_pk(SK_EU_PROFILE) in

  (* Response with KEM to SM-DP+ *)
  new r_resp : KEMcoin_t;
  let CT_RESP = kem_enc(PK_SMDP_KEM, r_resp) in
  let SS_RESP = kem_ss(PK_SMDP_KEM, r_resp) in
  let k_resp = kdf_bind(SS_RESP, tid) in
  let resp_mac = mac(k_resp, msg_response(tid, PK_EU_PROFILE)) in

  (* Step 2: Send response via ES9 *)
  out(ES9, (tid, PK_EU_PROFILE, CT_RESP, resp_mac));

  (* Step 3: Receive profile package via ES9 *)
  in(ES9,
     (tid_bpp        : Tid_t,
      CT_PROFILE     : bitstring,
      encrypted_prof : bitstring,
      profile_mac_in : bitstring,
      CT_AUTH        : bitstring,
      auth_mac_in    : bitstring));
  if tid_bpp = tid then

  (* Verify auth KEM: proves sender knows PK_EUICC_KEM from cert *)
  let SS_AUTH = kem_dec(CT_AUTH, SK_EUICC_KEM) in
  let k_auth = kdf_auth(SS_AUTH, tid) in
  let expected_auth_mac = mac(k_auth, msg_profile(tid, CT_PROFILE, encrypted_prof)) in
  if auth_mac_in = expected_auth_mac then

  (* Decrypt profile *)
  let SS_PROFILE = kem_dec(CT_PROFILE, SK_EU_PROFILE) in
  let k_profile = kdf_profile(SS_PROFILE) in

  let expected_profile_mac = mac(k_profile, msg_profile(tid, CT_PROFILE, encrypted_prof)) in
  if profile_mac_in = expected_profile_mac then

  let profile = sdec(encrypted_prof, k_profile) in
  new iccid : ICCID_t;
  event EUICC_PROFILE_INSTALLED(dev, tid, profile, iccid);

  (* Step 4: Send install confirmation via ES9 *)
  new r_install : KEMcoin_t;
  let CT_INSTALL = kem_enc(PK_SMDP_KEM, r_install) in
  let SS_INSTALL = kem_ss(PK_SMDP_KEM, r_install) in
  let k_install = kdf_install(SS_INSTALL, tid, iccid, PK_EU_PROFILE, CT_PREPARE) in
  let install_mac = mac(k_install, msg_install(tid, iccid, PK_EU_PROFILE)) in

  out(ES9, (tid, iccid, CT_INSTALL, install_mac)).



(* =====================================================================
   SM-DP+ PROCESS - Phase B Only (Public ES9+)
   ===================================================================== *)
let SMDP(dev:Id_t, tid:Tid_t, PK_EUICC_KEM:KEMpk_t, profile:Profile_t) =
  let PK_SMDP_KEM = kem_pk(SK_SMDP_KEM) in

  (* Step 1: Send PrepareDownload via ES9 *)
  new r_prepare : KEMcoin_t;
  let CT_PREPARE = kem_enc(PK_EUICC_KEM, r_prepare) in
  let SS_PREPARE = kem_ss(PK_EUICC_KEM, r_prepare) in
  let k_prepare = kdf_bind(SS_PREPARE, tid) in
  let prepare_mac = mac(k_prepare, msg_prepare(tid)) in

  out(ES9, (tid, CT_PREPARE, prepare_mac));

  (* Step 2: Receive response via ES9 *)
  in(ES9,
     (tid3        : Tid_t,
      PK_EU_PROFILE: KEMpk_t,
      CT_RESP     : bitstring,
      resp_mac    : bitstring));
  if tid3 = tid then

  let SS_RESP = kem_dec(CT_RESP, SK_SMDP_KEM) in
  let k_resp = kdf_bind(SS_RESP, tid) in
  let expected_resp_mac = mac(k_resp, msg_response(tid, PK_EU_PROFILE)) in
  if resp_mac = expected_resp_mac then

  (* Encrypt profile to eUICC's ephemeral key *)
  new r_profile : KEMcoin_t;
  let CT_PROFILE = kem_enc(PK_EU_PROFILE, r_profile) in
  let SS_PROFILE = kem_ss(PK_EU_PROFILE, r_profile) in

  let k_profile = kdf_profile(SS_PROFILE) in

  let encrypted_profile = senc(profile, k_profile) in
  let profile_mac_out = mac(k_profile, msg_profile(tid, CT_PROFILE, encrypted_profile)) in

  (* Auth KEM: encapsulate to eUICC's long-term key for identity binding *)
  new r_auth : KEMcoin_t;
  let CT_AUTH = kem_enc(PK_EUICC_KEM, r_auth) in
  let SS_AUTH = kem_ss(PK_EUICC_KEM, r_auth) in
  let k_auth = kdf_auth(SS_AUTH, tid) in
  let auth_mac_out = mac(k_auth, msg_profile(tid, CT_PROFILE, encrypted_profile)) in

  event SMDP_BOUND_PROFILE(dev, tid, profile);

  (* Step 3: Send profile package with auth KEM via ES9 *)
  out(ES9, (tid, CT_PROFILE, encrypted_profile, profile_mac_out, CT_AUTH, auth_mac_out));

  (* Step 4: Receive install confirmation via ES9 *)
  in(ES9,
     (tid4      : Tid_t,
      iccid     : ICCID_t,
      CT_INSTALL: bitstring,
      install_mac: bitstring));
  if tid4 = tid then

  let SS_INSTALL = kem_dec(CT_INSTALL, SK_SMDP_KEM) in
  let k_install = kdf_install(SS_INSTALL, tid, iccid, PK_EU_PROFILE, CT_PREPARE) in
  let expected_install_mac = mac(k_install, msg_install(tid, iccid, PK_EU_PROFILE)) in
  if install_mac = expected_install_mac then

  event SMDP_INSTALL_CONFIRMED(dev, tid, iccid).



(* =====================================================================
   MAIN PROCESS - Phase B with forward secrecy phase
   ===================================================================== *)
process
  new devMain : Id_t;
  new tidMain : Tid_t;

  (* Setup KEM keys (simulating Phase A results) *)
  new SK_EUICC_KEM : KEMsk_t;
  let PK_EUICC_KEM = kem_pk(SK_EUICC_KEM) in
  let PK_SMDP_KEM = kem_pk(SK_SMDP_KEM) in

  (
    ( !SMDP(devMain, tidMain, PK_EUICC_KEM, secret_profile)
    | !EUICC(devMain, tidMain, PK_SMDP_KEM, SK_EUICC_KEM)
    )
    (* Forward Secrecy Test: leak ALL long-term keys *)
  | ( phase 1;
      out(c, SK_SMDP_KEM);
      out(c, SK_EUICC_KEM)
    )
  )
