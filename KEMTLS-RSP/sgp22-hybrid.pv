(* =====================================================================
   SGP.22 eSIM Provisioning - Hybrid PQC (ECDH + ML-KEM-768)
   
   Extended from original mutual authentication model by Yongho Ko
   
   Additions:
   - ML-KEM-768 key encapsulation
   - ECDH P-256 key exchange (classical)
   - Hybrid KDF for session key derivation
   - Session key secrecy verification
   
   Config B: Hybrid approach (ECDH + ML-KEM)
   ===================================================================== *)

(* ===== CHANNELS ===== *)
free c         : channel.           (* Public channel: certs, meta *)
free IPA2EUICC : channel [private]. (* Local IPA ↔ eUICC interface *)
free IPA2SMDP  : channel [private]. (* HTTPS/TLS-abstracted channel *)


(* ===== DATA TYPES ===== *)
type Id_t.      (* Entity identifier (SMDP, IPA, EUICC, device) *)
type Tid_t.     (* TransactionID *)
type Nonce_t.   (* Challenges *)
type K_t.       (* Keys (long-term signing keys) *)
type Sig_t.     (* Digital signatures *)
type Cert_t.    (* Certificates *)
type Tag_t.     (* Roles / message tags *)

(* PQC key types *)
type MLKEMsk_t.    (* ML-KEM secret key *)
type MLKEMpk_t.    (* ML-KEM public key *)
type MLKEMct_t.    (* ML-KEM ciphertext *)
type MLKEMss_t.    (* ML-KEM shared secret *)

(* Classical ECDH types *)
type ECDHsk_t.     (* ECDH secret key *)
type ECDHpk_t.     (* ECDH public key *)
type ECDHss_t.     (* ECDH shared secret *)

(* Session key types *)
type SessionKey_t. (* Derived session key bundle (KEK + KM) *)
type KEK_t.        (* Key Encryption Key *)
type KM_t.         (* MAC Key *)


(* ===== CONSTANTS ===== *)
(* Entity IDs *)
const ID_SMDP   : Id_t.
const ID_IPA    : Id_t.
const ID_EUICC  : Id_t.

(* Role tags *)
const tag_ci    : Tag_t.
const tag_dp    : Tag_t.
const tag_eu    : Tag_t.

(* Message tags *)
const t_getChal : Tag_t.

(* Root CI secret key *)
const SK_CI     : K_t [private].
const SK_DPauth : K_t [private].


(* ===== CRYPTO PRIMITIVES - SIGNATURES & CERTIFICATES ===== *)
fun pk(K_t) : K_t.

fun signcert(Id_t, K_t, Tag_t, K_t) : Cert_t.
reduc forall id   : Id_t,
             Pk   : K_t,
             role : Tag_t,
             Sk   : K_t;
  checkcert(signcert(id, Pk, role, Sk), pk(Sk)) = (id, Pk, role).

letfun certificate(id:Id_t, Pk:K_t, role:Tag_t) =
  signcert(id, Pk, role, SK_CI).

fun sign(bitstring, K_t) : Sig_t.
reduc forall m  : bitstring,
             Sk : K_t;
  checksign(sign(m, Sk), pk(Sk)) = m.

fun mk_serverSigned(Tid_t, Nonce_t, Nonce_t, Id_t, ECDHpk_t, MLKEMct_t) : bitstring [data].
fun mk_clientSigned(Tid_t, Nonce_t, ECDHpk_t, MLKEMpk_t) : bitstring [data].


(* ===== CRYPTO PRIMITIVES - ML-KEM ===== *)
(* ML-KEM public key generation *)
fun mlkem_pk(MLKEMsk_t) : MLKEMpk_t.

(* ML-KEM encapsulation: returns (ciphertext, shared_secret) *)
fun mlkem_encaps(MLKEMpk_t) : bitstring.

(* Extract ciphertext and shared secret from encapsulation result *)
fun mlkem_get_ct(bitstring) : MLKEMct_t [data].
fun mlkem_get_ss(bitstring) : MLKEMss_t [data].

(* ML-KEM decapsulation: extract shared secret from ciphertext *)
reduc forall sk : MLKEMsk_t;
  mlkem_decaps(mlkem_get_ct(mlkem_encaps(mlkem_pk(sk))), sk) = 
    mlkem_get_ss(mlkem_encaps(mlkem_pk(sk))).


(* ===== CRYPTO PRIMITIVES - ECDH ===== *)
(* ECDH public key generation *)
fun ecdh_pk(ECDHsk_t) : ECDHpk_t.

(* ECDH shared secret computation *)
fun ecdh_shared(ECDHsk_t, ECDHpk_t) : ECDHss_t.

(* ECDH property: shared secret is symmetric *)
equation forall ska : ECDHsk_t, skb : ECDHsk_t;
  ecdh_shared(ska, ecdh_pk(skb)) = ecdh_shared(skb, ecdh_pk(ska)).


(* ===== HYBRID KEY DERIVATION FUNCTION ===== *)
(* 
   Implements Algorithm 2 from paper:
   hybrid_kdf(Z_ecdh, Z_mlkem, eChal, sChal, ID_eu, ID_smdp) → (KEK, KM)
   
   Inputs:
   - Z_ecdh: ECDH shared secret
   - Z_mlkem: ML-KEM shared secret
   - eChal: eUICC challenge (for freshness)
   - sChal: SMDP challenge (for freshness)
   - ID_eu: eUICC identifier (for binding)
   - ID_smdp: SMDP identifier (for binding)
   
   Output: SessionKey bundle containing KEK and KM
*)
fun hybrid_kdf(ECDHss_t, MLKEMss_t, Nonce_t, Nonce_t, Id_t, Id_t) : SessionKey_t.

(* Extract KEK and KM from session key bundle *)
fun get_KEK(SessionKey_t) : KEK_t [data].
fun get_KM(SessionKey_t) : KM_t [data].


(* ===== EVENTS ===== *)
(* Original mutual authentication events *)
event S_AUTH_BEGIN(Id_t, Tid_t).     (* Server-side auth session start *)
event U_AUTH_OK(Id_t, Tid_t).        (* eUICC finished server auth *)
event S_AUTH_OK(Id_t, Tid_t).        (* SMDP finished client auth *)

(* New key establishment events *)
event U_KEY_DERIVED(Id_t, Tid_t, SessionKey_t).  (* eUICC derived session key *)
event S_KEY_DERIVED(Id_t, Tid_t, SessionKey_t).  (* SMDP derived session key *)


(* ===== QUERIES ===== *)

(* --- Original Mutual Authentication Queries --- *)
(* eUICC server-auth implies server started that session *)
query U:Id_t, tid:Tid_t;
  event(U_AUTH_OK(U, tid))  ==>  inj-event(S_AUTH_BEGIN(U, tid)).

(* SMDP client-auth implies eUICC has server-auth OK *)
query U2:Id_t, tid2:Tid_t;
  event(S_AUTH_OK(U2, tid2))  ==>  inj-event(U_AUTH_OK(U2, tid2)).


(* --- New PQC Key Establishment Queries --- *)
(* Session key secrecy: attacker cannot learn KEK or KM *)
free test_session_key : SessionKey_t [private].
query attacker(get_KEK(test_session_key)).
query attacker(get_KM(test_session_key)).

(* Key agreement: both parties derive the same session key *)
query dev:Id_t, tid:Tid_t, k:SessionKey_t;
  event(S_KEY_DERIVED(dev, tid, k)) ==> event(U_KEY_DERIVED(dev, tid, k)).

(* Injective agreement: unique session keys per transaction *)
query dev:Id_t, tid:Tid_t, k:SessionKey_t;
  inj-event(S_KEY_DERIVED(dev, tid, k)) ==> inj-event(U_KEY_DERIVED(dev, tid, k)).


(* ===== eUICC – HONEST PROCESS WITH HYBRID PQC ===== *)
let EUICC_HONEST(PK_CI:K_t, dev:Id_t) =
  (* ==================== ORIGINAL: Long-term identity ==================== *)
  (* eUICC long-term signing keypair *)
  new SK_EUICC:K_t;
  let PK_EUICC   = pk(SK_EUICC) in
  let Cert_EUICC = certificate(ID_EUICC, PK_EUICC, tag_eu) in

  (* Publish certificate *)
  out(c, Cert_EUICC);

  (* ==================== NEW: Ephemeral session keys ==================== *)
  (* Generate ephemeral ECDH keypair for this session *)
  new SK_EUICC_ECDH : ECDHsk_t;
  let PK_EUICC_ECDH = ecdh_pk(SK_EUICC_ECDH) in

  (* Generate ephemeral ML-KEM keypair for this session *)
  new SK_EUICC_MLKEM : MLKEMsk_t;
  let PK_EUICC_MLKEM = mlkem_pk(SK_EUICC_MLKEM) in

  (
    (* ==================== STEP 2-4: Challenge Exchange ==================== *)
    (* (2) IPA -> eUICC: GetEUICCChallenge *)
    in(IPA2EUICC, (=t_getChal, =ID_IPA, dev_in:Id_t));
    if dev_in = dev then

    (* (3) eUICC generates fresh challenge *)
    new eChal:Nonce_t;

    (* (4) MODIFIED: Return challenge + ephemeral public keys *)
    out(IPA2EUICC, (dev, eChal, PK_EUICC_ECDH, PK_EUICC_MLKEM));

    (* ==================== STEP 11: Server Authentication ==================== *)
    (* (11) AuthenticateServer – IPA -> eUICC *)
    in(IPA2EUICC,
       (dev_srv        : Id_t,
        serverSigned   : bitstring,
        serverSig      : Sig_t,
        Cert_DPauth    : Cert_t,
        (* NEW: SMDP's ephemeral public key and ML-KEM ciphertext *)
        PK_SMDP_ECDH   : ECDHpk_t,
        CT_MLKEM       : MLKEMct_t));
    if dev_srv = dev then

    (* ==================== ORIGINAL: Verify SMDP certificate ==================== *)
    let (id_dp     : Id_t,
         PK_DPauth : K_t,
         role_dp   : Tag_t) =
      checkcert(Cert_DPauth, PK_CI) in

    (* ==================== ORIGINAL: Verify server signature ==================== *)
    let decoded_srv:bitstring =
      checksign(serverSig, PK_DPauth) in

    let mk_serverSigned(tidU       : Tid_t,
                        eChalU     : Nonce_t,
                        sChalU     : Nonce_t,
                        smdpAddrU  : Id_t,
                        PK_SMDP_U  : ECDHpk_t,
                        CT_MLKEM_U : MLKEMct_t) = decoded_srv in

    (* Challenge verification *)
    if eChalU = eChal then
    if smdpAddrU = ID_SMDP then
    (* Verify ephemeral keys match what was received *)
    if PK_SMDP_U = PK_SMDP_ECDH then
    if CT_MLKEM_U = CT_MLKEM then

    (* ==================== ORIGINAL: Mutual auth event ==================== *)
    event U_AUTH_OK(dev, tidU);

    (* ==================== NEW: Hybrid Key Agreement ==================== *)
    (* (12a) Compute ECDH shared secret *)
    let Z_ECDH = ecdh_shared(SK_EUICC_ECDH, PK_SMDP_ECDH) in

    (* (12b) ML-KEM decapsulation *)
    let Z_MLKEM = mlkem_decaps(CT_MLKEM, SK_EUICC_MLKEM) in

    (* (12c) Derive session keys using Hybrid KDF (Algorithm 2) *)
    let session_key = hybrid_kdf(Z_ECDH, Z_MLKEM, eChal, sChalU, 
                                  ID_EUICC, ID_SMDP) in
    
    (* Extract KEK and KM *)
    let KEK = get_KEK(session_key) in
    let KM  = get_KM(session_key) in

    (* ==================== NEW: Key derivation event ==================== *)
    event U_KEY_DERIVED(dev, tidU, session_key);

    (* ==================== ORIGINAL: Client Authentication Response ==================== *)
    (* (13) eUICC generates clientSigned and signature *)
    let clientSigned = mk_clientSigned(tidU, sChalU, PK_EUICC_ECDH, PK_EUICC_MLKEM) in
    let clientSig    = sign(clientSigned, SK_EUICC) in

    (* (14) Send to IPA *)
    out(IPA2EUICC,
        (dev, clientSigned, clientSig, Cert_EUICC))
    
    (* ==================== END: Mutual Auth + Key Establishment Complete ==================== *)
  ).



(* ===== SMDP+ – HONEST PROCESS WITH HYBRID PQC ===== *)
let SMDP_HONEST(PK_CI:K_t, dev:Id_t) =
  (* ==================== ORIGINAL: SMDP identity ==================== *)
  (* SMDP's public identity and certificate *)
  let PK_DPauth   = pk(SK_DPauth) in
  let Cert_DPauth = certificate(ID_SMDP, PK_DPauth, tag_dp) in

  (* Publish SMDP certificate *)
  out(c, Cert_DPauth);

  (* ==================== NEW: Ephemeral session keys ==================== *)
  (* Generate ephemeral ECDH keypair for this session *)
  new SK_SMDP_ECDH : ECDHsk_t;
  let PK_SMDP_ECDH = ecdh_pk(SK_SMDP_ECDH) in

  (
    (* ==================== STEP 6: Receive eUICC Challenge ==================== *)
    (* (6) IPA -> SMDP: dev, eChal, ephemeral public keys *)
    in(IPA2SMDP,
       (devS          : Id_t,
        eChalS        : Nonce_t,
        (* NEW: eUICC's ephemeral public keys *)
        PK_EUICC_ECDH : ECDHpk_t,
        PK_EUICC_MLKEM: MLKEMpk_t));
    if devS = dev then

    (* ==================== ORIGINAL: Session parameters ==================== *)
    (* (8a) TransactionID *)
    new tid   : Tid_t;
    (* (8b) serverChallenge *)
    new sChal : Nonce_t;

    (* Server begins auth session *)
    event S_AUTH_BEGIN(devS, tid);

    (* ==================== NEW: Hybrid Key Agreement ==================== *)
    (* (8c) Perform ML-KEM encapsulation *)
    let encaps_result = mlkem_encaps(PK_EUICC_MLKEM) in
    let CT_MLKEM = mlkem_get_ct(encaps_result) in
    let Z_MLKEM  = mlkem_get_ss(encaps_result) in

    (* (8d) Compute ECDH shared secret *)
    let Z_ECDH = ecdh_shared(SK_SMDP_ECDH, PK_EUICC_ECDH) in

    (* (8e) Derive session keys using Hybrid KDF *)
    let session_key = hybrid_kdf(Z_ECDH, Z_MLKEM, eChalS, sChal,
                                  ID_EUICC, ID_SMDP) in
    
    (* Extract KEK and KM *)
    let KEK = get_KEK(session_key) in
    let KM  = get_KM(session_key) in

    (* ==================== ORIGINAL: Server signature ==================== *)
    (* (8f,g) Create serverSigned, serverSig *)
    let serverSigned =
      mk_serverSigned(tid, eChalS, sChal, ID_SMDP, PK_SMDP_ECDH, CT_MLKEM) in
    let serverSig = sign(serverSigned, SK_DPauth) in

    (* (9) MODIFIED: Send to IPA with PQC material *)
    out(IPA2SMDP,
        (devS,
         serverSigned,
         serverSig,
         Cert_DPauth,
         (* NEW: SMDP's ephemeral ECDH key and ML-KEM ciphertext *)
         PK_SMDP_ECDH,
         CT_MLKEM));

    (* ==================== STEP 15: Client Authentication ==================== *)
    (* (15) IPA -> SMDP: dev, clientSigned, clientSig, Cert_EUICC *)
    in(IPA2SMDP,
       (devS2        : Id_t,
        clientSigned : bitstring,
        clientSig    : Sig_t,
        Cert_EUICC   : Cert_t));
    if devS2 = dev then

    (* ==================== ORIGINAL: Verify eUICC certificate ==================== *)
    let (id_eu    : Id_t,
         PK_EUICC : K_t,
         role_eu  : Tag_t) =
      checkcert(Cert_EUICC, PK_CI) in

    (* ==================== ORIGINAL: Verify client signature ==================== *)
    let decoded_cli:bitstring =
      checksign(clientSig, PK_EUICC) in

    let mk_clientSigned(tid2            : Tid_t,
                        sChal2          : Nonce_t,
                        PK_EUICC_ECDH_V : ECDHpk_t,
                        PK_EUICC_MLKEM_V: MLKEMpk_t) = decoded_cli in

    (* Check same session *)
    if tid2   = tid then
    if sChal2 = sChal then
    (* Verify ephemeral keys match what was received *)
    if PK_EUICC_ECDH_V = PK_EUICC_ECDH then
    if PK_EUICC_MLKEM_V = PK_EUICC_MLKEM then

    (* ==================== ORIGINAL: Client auth OK ==================== *)
    event S_AUTH_OK(dev, tid);

    (* ==================== NEW: Key derivation event (after mutual auth) ==================== *)
    event S_KEY_DERIVED(devS, tid, session_key)
    
    (* ==================== END: Mutual Auth + Key Establishment Complete ==================== *)
  ).



(* ===== IPA – HONEST RELAY WITH PQC FORWARDING ===== *)
let IPA_HONEST(PK_CI:K_t, dev:Id_t) =
  (
    (* ==================== STEP 1-4: Challenge Request ==================== *)
    (* (1) eIM package has already selected target device dev *)
    
    (* Request eUICC challenge *)
    out(IPA2EUICC, (t_getChal, ID_IPA, dev));

    (* MODIFIED: eUICC returns challenge + ephemeral public keys *)
    in(IPA2EUICC, (dev_ch      : Id_t, 
                   eChal       : Nonce_t, 
                   PK_EUICC_ECDH  : ECDHpk_t,
                   PK_EUICC_MLKEM : MLKEMpk_t));
    if dev_ch = dev then

    (* ==================== STEP 5-6: Forward to SMDP ==================== *)
    (* MODIFIED: Forward challenge + ephemeral keys to SMDP *)
    out(IPA2SMDP, (dev, eChal, PK_EUICC_ECDH, PK_EUICC_MLKEM));

    (* ==================== STEP 9-10: Forward SMDP Response ==================== *)
    (* MODIFIED: Receive SMDP's serverSigned, cert, and PQC material *)
    in(IPA2SMDP,
       (dev2         : Id_t,
        serverSigned : bitstring,
        serverSig    : Sig_t,
        Cert_DPauth  : Cert_t,
        PK_SMDP_ECDH : ECDHpk_t,
        CT_MLKEM     : MLKEMct_t));
    if dev2 = dev then

    (* MODIFIED: Forward to eUICC for AuthenticateServer *)
    out(IPA2EUICC,
        (dev, serverSigned, serverSig, Cert_DPauth,
         PK_SMDP_ECDH, CT_MLKEM));

    (* ==================== STEP 14-15: Forward eUICC Response ==================== *)
    (* ORIGINAL: Receive client response from eUICC *)
    in(IPA2EUICC,
       (dev3         : Id_t,
        clientSigned : bitstring,
        clientSig    : Sig_t,
        Cert_EUICC   : Cert_t));
    if dev3 = dev then

    (* ORIGINAL: Forward to SMDP for AuthenticateClient *)
    out(IPA2SMDP,
        (dev, clientSigned, clientSig, Cert_EUICC))
  ).



(* ===== MAIN PROCESS ===== *)
process
  (* CI public key distribution *)
  let PK_CI = pk(SK_CI) in
  out(c, PK_CI);

  (* Single device / single-session instance – Mutual Auth + Key Establishment *)
  new devMain:Id_t;
  ( !SMDP_HONEST(PK_CI, devMain)
  | !IPA_HONEST(PK_CI, devMain)
  | !EUICC_HONEST(PK_CI, devMain)
  )
  
  (* OPTIONAL: Post-quantum forward secrecy test
     Uncomment to verify that leaking long-term keys doesn't compromise session keys *)
  | ( phase 1;
      out(c, (SK_CI, SK_DPauth))
    )
  